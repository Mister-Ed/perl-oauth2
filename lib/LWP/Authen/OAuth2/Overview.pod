=head1 Introduction

This is an overview of OAuth 2, the terminology around it, and what
L<LWP::Authen::OAuth2> does to make it easier.  Whether or not you
eventually use L<LWP::Authen::OAuth2>, this document is likely to be a good
starting point for learning OAuth 2.

There is, unfortunately, a lot of OAuth 2 specific terminology that gets
used.  That terminology is likely to be consistently used in any
documentation from anyone else, so it is used here.  That will be
I<highlighted> in this document to help you keep track.

In OAuth 2 a I<user> (called a I<resource owner> in the specification) with
an account on a I<service provider>'s website (aka the I<resource server>)
would like to give a third party I<consumer> (aka the I<client>) access to
the account.  The OAuth 2 protocol sets up a 3-way handshake with a
I<authorization server> (usually run by the I<service provider>) through
which this permission can be securely granted.  Once granted, the
I<consumer> can access the I<service provider>'s API.

(To avoid having two sets of parallel terms, the rest of the document will
use I<user>, I<service provider> and I<consumer> instead of
I<resource owner>, I<resource server> and I<client>.  The
I<authorization server> will be assumed to be part of the I<service provider>
even though they technically can be separated.)

That handshake requires a series of specific interactions between the three
parties.  L<LWP::Authen::OAuth2> provides convenience methods to simplify the
requests that the I<consumer> needs to construct which will go to the
I<service provider>.  In the spirit of do only one thing, it does NOTHING
else.  If you are the I<consumer> you will still need to build the
interactions with the I<user>, store data, and figure out the
I<service provider>'s API.  If you are not the I<consumer> then this module
will do nothing for you.

This document contains a high level overview of the
L</Basic OAuth 2 Interactions>, then a suspiciously similar but more
detailed description of I<Becoming a Consumer>, and finally a detailed
overview of L</Terminology> which is organized in the same way and also
explains the detailed interactions.

=head1 Basic OAuth 2 Interactions

The protocol describes several variations on how the I<user> interacts with
the I<consumer> and the I<service provider> (redirects, cut and paste
information, etc), but the basic pattern of interaction is constant.  If
you want more details about how any of these steps are done, it is
explained in the L</Terminology> section.

=over 4

=item * Construct Authorization URL

To start, the I<consumer> constructs an authorization URL which will tell
the I<service provider> that permissions are granted.
L<LWP::Authen::OAuth2> does this step.

=item * I<User> Tells I<Service Provider> To Authorize

The I<user> goes to the authorization URL, and interacts with the
I<service provider>.  The I<consumer> is not involved.

=item * I<User> Takes I<Code> Back To I<Consumer>

If all went well in the last step, the I<user> is given a one-use I<code> to
take back to the I<consumer>.  L<LWP::Authen::OAuth2> DOES NOT help with this
step.

=item * Get Access Token

The I<consumer> uses this I<code> together with secret information to
request a temporary I<access_token>.  If successful, a I<request_token>
might also be provided.  Success is not guaranteed.  Doubly not if you trip a
security check on the I<service provider>'s side such as using the I<code>
twice, sending suspicious requests, or anything else that they don't like.
The errors you get on failure are deliberately useless.  (They want the bad
guys to get frustrated and give up, not to figure out how to pretend to be
good guys.)

L<LWP::Authen::OAuth2> can make this request, and do useful things with a
successful answer.  On failure, it can do no better than die with a useless
message.

=item * Make Authorized Request

Once the I<consumer> has an unexpired I<access_token>, it can be used to
sign API requests to the I<service provider>.  L<LWP::Authen::OAuth2> will
sign these requests, but the details of the requests that need to be made
are between the I<consumer> and the I<service provider>.  Hopefully there is
accurate and useful documentation available to you.

=item * Refresh Access Token

As noted, the I<access_token> is temporary.  If the I<consumer> was given a
I<request_token>, that can be sent with secret information, and with luck a
new I<access_token> will be sent back.  All of the caveats for getting the
original access token apply to refreshing one.

If a I<request_token> was given then L<LWP::Authen::OAuth2> is able to
detect expiration, send this request, and then go back to send the original
API request.  If no I<request_token> is available, then
L<LWP::Authen::OAuth2> can die with an informative message, and it is up to
the programmer to notice, and do something useful.  Like ask the user to
authorize access again.

=item * Revoke Access

The I<service provider> may provide a way for the I<user> to review what
access has been granted to whom, and selectively revoke access.  If
access was revoked, then the I<request_token> that the I<consumer> has
becomes useless.

=back

=head1 Becoming a Consumer

(There is a lot of jargon here.  Hopefully the meaning can be guessed from
context.  If not, then L</Terminology> has definitions.)

Here are the things that you need to do to become an OAuth 2 I<consumer>.
It is presented here in the order that things will actually happen in, which
has obvious parallels to the handshake described above.

=over 4

=item Register with the I<service provider>

You cannot access a I<service provider> without them knowing who you are.
How you sign up is up to them.  However you will need a public
I<client_id>, a private I<client_secret>, and have agreed on one or more
I<redirect_uri>s that the I<user> can use to deliver your
I<authorization code> back to you.  (The I<redirect_uri> is often a
C<https:///...> URL under your control.)  In the process you may have been
forced to choose the exact variant of the protocol to use, which is called a
I<flow>.

They will also have an I<Authorization Endpoint> and a I<Token Endpoint>.
They may have important documentation on how they specifically implemented
things.  And you likely will have one or more APIs that you want to be able
to use.

This documentation may orient you, but L<LWP::Authen::OAuth2> is not
involved with this step.  However it will need to be passed all of the
above facts in some way.

If a L<LWP::Authen::OAuth2::ServiceProvider::Foo> class exists, it should
know the I<service provider> specific stuff, and may have useful information
about how to do the rest.  If you're really lucky, there may be a CPAN module
which takes care of the details of the API.  If those don't exist, please
consider contributing them.

If they do not exist, then you can still use this module.  Just pass the 
necessary facts in your call to C<LWP::Authen::OAuth2-E<gt>new(...)> and an
appropriate L<LWP::Authen::OAuth2::ServiceProvider> will be created for you
on the fly.

=item Decide how to store sensitive information

All of the data between you and the I<service provider> has to be stored on
your end.  You will also be receiving tokens that let you access private
information for the I<user>.  You need to be able to store and share those
between the places in your code that need access, while keeping them
secure.

L<LWP::Authen::OAuth2> does not assist you with this, nor does it do anything
that may make it harder.

=item Build interaction asking for I<user> permission

You need to have some way of convincing the I<user> that they want to give
you permission, ending in giving them an I<authorization_url> which sends
them off to the I<service provider> to authorize access.  This can range from
a trivial conversation with yourself if you are the only I<user> you will be
handling, to a carefully thought through sales pitch if you are trying to get
members of the public to sign up.

L<LWP::Authen::OAuth2> helps you build that URL, but does nothing else for
this step.

=item Build interaction receiving your I<authorization code>

When the I<user> finishes their interaction with the I<service provider>,
they are sent to the I<redirect_uri> to pass a one use I<code> back to you.
You need to be able to receive that information.  What is required depends
on your I<flow>, but it is likely that the user will be sent to a URL that you
control with a get parameter named C<code>.  You need to be able to retrieve
the I<code> from there.

L<LWP::Authen::OAuth2> is not involved in this step.

=item Request tokens

Once you have that I<code> you are supposed to immediately trade it in
for tokens.  L<LWP::Authen::OAuth2> provides the C<request_tokens>
method to do this for you.

=item Save and pass around tokens (maybe)

If you will need access to information in multiple locations (for instance
on several different web pages), then you are responsible for saving and
retrieving those tokens for future use.  L<LWP::Authen::OAuth2> makes it
easy to serialize/deserialize tokens, but leaves this step up to you.

=item Access the API

L<LWP::Authen::OAuth2> takes care of signing your API requests.  What
requests you need to actually make are between you and the
I<service provider>.  With luck there will be documentation to help you
figure it out, and if you are really lucky that will be reasonably accurate.

=item Refresh access tokens (maybe)

The I<access token> that is used to sign requests will only work for a
limited time.  If you were given a I<request token>, that can be used to
request another I<access token> at any time.  Which raises the possibility
that you make a request, it fails because the I<access token> expired, you
refresh it, then need to retry your request.

L<LWP::Authen::OAuth2> will perform this refresh/retry logic for you
automatically if possible, and provides a hook for you to save the updated
tokens on request.

Some I<flow>s do not support this pattern.  You are only given an
I<access token> and are expected to go through the handshake again when
that expires.  In this case the redirect on the I<service provider>'s side is
immediate, so the user experience is seamless.  However since
L<LWP::Authen::OAuth2> does not try to automate that handshake, on these
I<flow>s you will need to detect that and do the handshake again.

=back

=head1 Terminology

There is a lot of specific terminology that gets thrown around, and there
are a lot of specific pieces to the requests that are made.  Here is a list
of those terms, along with an explanation of what each one is.  In the
process of defining those, it becomes easy to say exactly what happens at
each step, so I do.  Therefore this can double as a practical introduction
to how the protocol actually works.

Unless you want to understand what happens under the hood, you can safely
write code without reading farther.

=over 4

=item consumer

The I<consumer> is the one who wants to be able to use an API to access an
account that exists on another website.  If you are a software developer,
you are probably the consumer.

=item user

The I<user> is the entity (person or company) who wishes to let the
I<consumer> access their account.

=item service provider

The I<service provider> is the website which hosts the account, and offers
the API.  For example, Google.

=item flow

Several different mechanisms are used to pass information during the
handshake, ranging from sending redirects to the I<user> to telling the
I<user> to enter data by hand.  The exact variation used is called your
I<flow>.

=item client_id

The I<client_id> is a public ID that tells the I<service provider> both who
the I<consumer> is, and what I<flow> to use.  Being public, it can be shared
with the I<user>.  The details of how this is assigned are between the
I<consumer> and the I<service provider>.

=item client_secret

The I<client_secret> is a somewhat private piece of information that the
I<consumer> can pass to the I<service provider> to prove that the request
really comes from the I<consumer>.  How private this piece of information is
considered will depend on the I<flow>.  A secret that is kept on a webserver
is expected to be completely private.  One that is inside of an application
running on the I<user>'s machine is trusted less.  (The consequences of this
are up to the I<service provider>.)

=item redirect_uri

The I<service provider> needs a way to tell the I<user> how to pass
information back to the I<consumer> in a secure way.  That is provided by the
I<redirect_uri> which can be anything from a C<https://...> URL that the
I<consumer> controls to a string that lets the I<service provider> know that
it should tell the I<user> to cut and paste some information.

=item state

The I<state> is an optional piece of information that can be created by the
I<consumer> then added to all requests as an extra piece of protection
against forgery.  It is optional for most I<flow>s, but is recommended by
the OAuth 2 specification, and could be required by the I<service provider>.

=item scope

The I<scope> describes what permissions are to be granted.  To get multiple
permissions, you need to join the permissions requested with spaces.  The
specification stops here.  What permissions can be requested, what they mean,
whether you can (or need) to have this will vary by I<service provider>.

=item Authorization Endpoint

The I<Authorization Endpoint> is the URL provided by the I<service provider>
for the purpose of sending requests to authorize the I<consumer> to access
the I<user>'s account.

=item response_type

The I<response_type> tells the I<service provider> what kind of information
it is supposed to pass back.  This usually has to be C<code>.  However some
I<service provider>s in some I<flow>s will allow other values.  For example
there are I<flow>s for JavaScript applications that want to send AJAX
requests in which the I<response_type> could be C<token>.

I am not aware of any I<service provider> and I<flow> where a I<consumer>
written in Perl would reasonably use any I<response_type> other than C<code>.
In an ideal world this field could be understood from the I<flow> associated
with the I<client_id> and the interaction simplified, but that isn't what the
specification says.  Therefore any I<service provider> who does things that
way is not OAuth 2 compliant.

Don't you love specifications written by committee?

=item authorization_url

This is the URL on the I<service provider>'s website that the I<user> goes to
in order to let the I<service provider> know what authorization is being
requested.

It is constructed as the I<Authorization Endpoint> with get parameters added
for the I<response_type> and I<client_id>.  The I<redirect_uri>, I<state>
and I<scope> may or may not be present or required by the
I<service provider>.  Also the I<service provider> can add on any other
required or optional arguments that they wish for your I<flow>.

An example URL for Google complete with optional extensions is
L<https://accounts.google.com/o/oauth2/auth?scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.profile&state=%2Fprofile&redirect_uri=https%3A%2F%2Foauth2-login-demo.appspot.com%2Fcode&response_type=code&client_id=812741506391.apps.googleusercontent.com&approval_prompt=force>

In L<LWP::Authen::OAuth2> the C<authorization_url> method constructs this
URL.  If your request needs to include the I<state>, I<scope>, or any
I<service provider> specific parameter, you need to pass those as
parameters.  The others are usefully defaulted from the service provider
and object.

=item (authorization) code

If the I<response_type> is set to C<code> (which should be the case), the
I<service provider> will generate a one use I<authorization code> to give to
the user to take back to the I<consumer>.  Depending on the I<flow> this
could happen with no effort on the part of the I<user>.  For example the
I<user> can be redirected to the I<redirect_uri> with the I<code> (and
optionally the I<state>) passed as get parameters.  The web server would then
pick these up, finish the handshake, and then redirect the user elsewhere.

In all interactions where it is passed it is simply called the I<code>.  But
it is described in one interaction as an I<authorization_code>.

=item Token Endpoint

The I<Token Endpoint> is the URL provided by the I<service provider>
for the purpose of sending requests from the I<consumer> to get tokens
allowing access to the I<user>'s account.

=item grant_type

The I<grant_type> is the type of grant you expected to get based on the
I<response_type> requested in the I<authorization_url>.  For a
I<response_type> of C<code> (which is almost certainly what will be used
with any I<consumer> written in Perl), the I<grant_type> has to be
C<authorization_code>.  If they were being consistent, then that would be
I<code> like it is everywhere else, but that's what the spec says.

We will later encounter the I<grant_type> C<refresh_token>.  This fact
makes it more useful than I<response_type> was.

=item Access Token Request

Once the I<consumer> has a I<code> the consumer can submit an
I<Access Token Request> by sending a POST request to the
I<Token Endpoint> with the I<grant_type>, I<code>, I<client_id>,
I<client_secret>, I<redirect_uri> and (if in the authorization code)
the I<state>.  Your I<service provider> may also want you to authenticate
in some other way.  You will get back a JSON response.

An example request might look like this:

    POST /o/oauth2/token HTTP/1.1
    Host: accounts.google.com
    Content-Type: application/x-www-form-urlencoded
    
    code=4/P7q7W91a-oMsCeLvIaQm6bTrgtp7&
    client_id=8819981768.apps.googleusercontent.com&
    client_secret={client_secret}&
    redirect_uri=https://oauth2-login-demo.appspot.com/code&
    grant_type=authorization_code

and the response if you're lucky will look something like:

    HTTP/1.1 200 OK
    Content-Type: application/json;charset=UTF-8
    Cache-Control: no-store
    Pragma: no-cache
    
    {
      "access_token":"1/fFAGRNJru1FTz70BzhT3Zg",
      "expires_in":3920,
      "token_type":"Bearer",
      "request_token":"1/xEoDL4iW3cxlI7yDbSRFYNG01kVKM2C-259HOF2aQbI"
    }

Note that success is up to the I<service provider> which can decide not to
give you tokens for any reason that they want, including you asked twice,
they think the I<user> might be compromised, they don't like the I<consumer>,
or the phase of the Moon.  (I am not aware of any I<service provider> that
makes failure depend on the phase of the Moon, but the others are realistic
examples.)

The C<request_tokens> method of L<LWP::Authen::OAuth2> will make this
request for you, read the JSON, and store the tokens.

=item access_token

An I<access_token> is a temporary token that gives the I<consumer> access to
the I<user>'s data in the I<service provider>'s system.  In the above
response the C<access_token> is the value of the token, C<expires_in> is the
number of seconds it is good for in theory (practice tends to be close but
not always exact), and C<token_type> specifies how it is supposed to be used.

=item Bearer token

A I<Bearer token> is a token that, until it expires, will works for anyone
who has it.  In the above example any https request with a header of:

    Authorization: Bearer 1/fFAGRNJru1FTz70BzhT3Zg

is automatically authorized.  This is the most common type of I<access_token>
but, depending on the I<service provider> and your I<flow>, you may be handed
another type of token that has to be signed in a different way.

Once you have completed your handshake, L<LWP::Authen::OAuth2> will
automatically sign any C<get>, C<post>, or C<put> for you.

=item request_token

The above example also included a I<request_token>.  If you were given one,
you can use it later to ask for a fresh I<access_token>.  Whether you get
one is up to your I<service provider>, who is likely to decide that based on
your I<flow>.

=item Refresh Access Token

If you have a I<request_token>, you can at any time send a
I<Refresh Access Token> request.  This is a POST to the I<Token Endpoint>
with the I<request_token>, I<client_id> and I<client_secret> arguments.  You
also have to send a I<grant_type> of C<refresh_token>.

Thus in the above case we'd send

    POST /o/oauth2/token HTTP/1.1
    Host: accounts.google.com
    Content-Type: application/x-www-form-urlencoded
    
    request_token=1/xEoDL4iW3cxlI7yDbSRFYNG01kVKM2C-259HOF2aQbI&
    client_id=8819981768.apps.googleusercontent.com&
    client_secret={client_secret}&
    grant_type=refresh_token

and if lucky could get a response like

    HTTP/1.1 200 OK
    Content-Type: application/json;charset=UTF-8
    Cache-Control: no-store
    Pragma: no-cache
    
    {
      "access_token":"ya29.AHES6ZSiArSow0zeKokajrri5gMBpGc6Sq",
      "expires_in":3600,
      "token_type":"Bearer",
    }

In L<LWP::Authen::OAuth2> this request can be made with the
C<refresh_access_token> method.  But you don't have to do that.  This request
will automatically be made for you when you try to access the API, it is
noticed that the I<access_token> has expired, and there is a I<request_token>
available.  And then your original request goes through unimpeded.

=back
